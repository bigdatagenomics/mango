#!/usr/bin/env bash
#
# Licensed to Big Data Genomics (BDG) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The BDG licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

shopt -s extglob

err_report() {
  local -ir line=$1
  local -ir exit_code=$2
  echo "Error on line ${line} with exit code ${exit_code}"
}

trap 'err_report $LINENO' ERR

print_err(){
  local -r msg="$1"
  printf 'ERROR: %s\n'  "${msg}" 1>&2
}

# Retrieve the full path of a program using its name. If the program is not
# found using $PATH viariable the script exit on error
#
# Usage program_exists [name] {true|false}
# Argument 1 program name
# Argument 2 optional boolean flag to exit or not if the program is not found
#            default is true (exit on error)
# Return full path or empty string if not found
get_program_path(){
  local -r name="$1"
  local -r exit_on_error=${2:-true}
  local -r path=$(command -v "${name}")
  if [[ -z "${path}" ]]; then
    if ${exit_on_error} ; then
      print_err "${name} is not found."
      exit 1
    else
      print_err "${name} is not found; Aborting."
    fi
  fi
  echo ${path}
}

get_py4jzip(){
  local -a py4j_zip_all_versions
  local py4j_zip=""
  if [[ -d "${SPARK_HOME}/python/lib" ]]; then
    py4j_zip_all_versions=( ${SPARK_HOME}/python/lib/py4j-+([0-9])\.+([0-9])?(\.+([0-9]))-src.zip )
    # use the latest version
    py4j_zip="${py4j_zip_all_versions[-1]}"
    if [[ ! -e ${py4j_zip} ]]; then
      err_report ${LINENO} $? "${py4j_zip} is not found; Aborting."
    fi
  fi
  echo "${py4j_zip}"
}

### MAIN ###
# variable declarations
trap 'err_report ${LINENO} $?' ERR
declare -r PY4J_ZIP=$(get_py4jzip)
declare -r SOURCE_DIR=$(dirname ${BASH_SOURCE[0]})

# Split args into Spark and ADAM args
DD=False  # DD is "double dash"
PRE_DD=()
POST_DD=()
for ARG in "$@"; do
  shift
  if [[ $ARG == "--" ]]; then
    DD=True
    POST_DD=( "$@" )
    break
  fi
  PRE_DD+=("$ARG")
done

if [[ $DD == True ]]; then
  SPARK_ARGS=("${PRE_DD[@]}")
  NOTEBOOK_ARGS=("${POST_DD[@]}")
else
  SPARK_ARGS=()
  NOTEBOOK_ARGS=("${PRE_DD[@]}")
fi

# get Mango jar
MANGO_CLI_JAR=$(${SOURCE_DIR}/find-mango-assembly.sh)

# get pyspark path
if [[ -z "${SPARK_HOME}" ]]; then
  wrapper_path=$(get_program_path spark-script-wrapper.sh false)
  if [[ -f "${wrapper_path}" ]]; then
    . ${wrapper_path}
    PYSPARK=$(find_script pyspark)
  else
    PYSPARK=$(get_program_path pyspark)
  fi
  SPARK_HOME=${PYSPARK/bin/pyspark}
else
  PYSPARK="${SPARK_HOME}"/bin/pyspark
fi

if [[ ! -f "${PYSPARK}" ]]; then
  print_err "pyspark was not found on PATH and SPARK_HOME; Aborting."
  exit 1
fi

# Use standard PYSPARK environement variables
if [[ -z ${PYSPARK_PYTHON} ]]; then
  export PYSPARK_PYTHON=$(get_program_path python)
fi

if [[ -z ${PYSPARK_DRIVER_PYTHON} ]]; then
  export PYSPARK_DRIVER_PYTHON=jupyter
fi

if [[ -z ${PYSPARK_DRIVER_PYTHON_OPTS} ]]; then
  export PYSPARK_DRIVER_PYTHON_OPTS="notebook ${NOTEBOOK_ARGS}"
else
  export PYSPARK_DRIVER_PYTHON_OPTS="${PYSPARK_DRIVER_PYTHON_OPTS} ${NOTEBOOK_ARGS}"
fi


export PYTHONPATH=${SPARK_HOME}/python:${SPARK_HOME}/python/lib/${PY4J_ZIP}:${PYTHONPATH}

${PYSPARK} \
  --conf spark.serializer=org.apache.spark.serializer.KryoSerializer \
  --conf spark.kryo.registrator=org.bdgenomics.mango.serialization.MangoKryoRegistrator \
  --jars ${MANGO_CLI_JAR} \
  --driver-class-path ${MANGO_CLI_JAR} \
  ${SPARK_ARGS[@]}
